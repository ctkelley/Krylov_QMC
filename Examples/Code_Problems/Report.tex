\documentclass[12pt]{siamltex}

\usepackage{savesym}
\RequirePackage[2018/12/01]{latexrelease}
\let\negmedspace\undefined
\let\negthickspace\undefined

\usepackage{tim,ma580}

\usepackage[nocolors]{jlcode}

\lstdefinestyle{code}{
  language=Julia,
  xleftmargin=1.5cm,
  showstringspaces=false,
  % Comment the following three lines to remove colors
%  keywordstyle=\color{blue},
%  commentstyle=\color{gray},
%  identifierstyle=\color[RGB]{0,102,0}
}
\lstnewenvironment{code}{
\lstset{
  language=Julia,
  xleftmargin=1.5cm,
  showstringspaces=false,
  % Comment the following three lines to remove colors
%  keywordstyle=\color{blue},
%  commentstyle=\color{gray},
%  identifierstyle=\color[RGB]{0,102,0}
}}{}

\title{Linearity Problems}

\author{Tim}

\begin{document}

\maketitle

\section{Overview}

Hi Sam, this is a bit to complicate to put in an email.

The issue is that we must be able to harvest the linear map from
the transport seep. I have a julia file {\tt LinearQMC.jl} with
the codes that generate the problem.

The problem is that linearity fails. We are dead until this gets fixed.

My tests all initialize {\tt qmc\_data} with 

\begin{code}
function EasyInit()
    #
    # Init with usual stuff
    #
    Nx = 10     # number of tally cells
    na2 = 11    # number of angles for angular mesh
    s = 1.0     # parameter in Garcia/Siewert
    N = 100    # number of particles per source itertion
    LB = 0.0   # left bound
    RB = 5.0   # right bound
    geometry = "Slab"
    generator = "Sobol"
    qmc_data = garcia_init(geometry, generator, N, LB, RB,
                            Nx, na2, s)
end
\end{code}



If I denote the transport sweep map for the flux by $\ms$, then in the 
language of your codes, I compute $\phi_{new} \ms(\phi)$ with

\begin{code}
phiout=qmc_sweep(phi,qmc_data)
phinew=phiout.phi_avg
\end{code}

Since I only need the cell-average flux from {\tt qmc\_sweep}, I wrote
a function that does that.

\begin{code}
function TSweep(phi, qmc_data)
    phiout = qmc_sweep(phi, qmc_data)
    phinew = phiout.phi_avg
    return phinew
end
\end{code}

A transport sweep is the sum of a linear operator applied to the input
flux and a constant term that comes from the boundary data and the fixed source.
\[
\ms(\phi) = \mm \phi + \vb
\]
So, to recover $\mm$ all I need to do is compute $\vb$, which is
\[
\vb = \ms({\overline 0}) = \mm {\overline 0} + \vb 
\]
where ${\overline 0}$ is the zero vector, and then
\[
\mm \phi = \ms(\phi) - \vb
\]

In Julia, we get $\vb$ from
\begin{code}
function getb(qmc_data)
    Nx = qmc_data.Nx
    zed = zeros(Nx)
    b = TSweep(zed, qmc_data)
    return b
end
\end{code}

So, I can now write the linear operator $\mm$ as
\begin{code}
function MMul(phi, qmc_data, b)
    mmul = TSweep(phi, qmc_data) - b
    return mmul
end
\end{code}

\section{Testing Linearity}

I am in great shape if {\tt MMul} is a linear map. This means that for
all vectors $\vx$ and $\vy$ and scalars $\alpha$ and $\beta$
\[
\mm(a \vx + b \vy) = a (\mm \vx) + b (\mm \vy)
\]
So I wrote a test to check
\begin{code}
function test1()
    qmc_data = EasyInit()
    b = getb(qmc_data)
    Nx = qmc_data.Nx
    linerror = 0.0
    for itest = 1:100
        x = rand(Nx)
        y = rand(Nx)
        alpha = rand()
        beta = rand()
        z = alpha * x + beta * y
        mz = MMul(z, qmc_data, b)
        mx = MMul(x, qmc_data, b)
        my = MMul(y, qmc_data, b)
        mxy = alpha * mx + beta * my
        linerror += norm(mz - mxy)
    end
    return linerror
end
\end{code}

When I run it I get
\begin{code}
julia> test1()
3.10686e-14
\end{code}

So things look good. But GMRES was breaking because the approximate
residuals were far from the real ones. The example I send you and Ryan
was the clue. I will test for linearity again with the two vectors from
that example. 

The problem from yesterday started with two vectors
\[
\phi_0 = (1, 1, \dots, 1)^T
\]
and
\[
\vr_0 = \ms(\phi_0) - \phi_0 = \vb + \mm \phi_0 - \phi_0.
\]
We got 
\[
\ms(\vr_0/\| \vr_0 \|) = \ms({\overline 0})
\]
which implies that $\mm \vr_0 = {\overline 0}$. 
I verify that in {\tt test2}, which
is pretty much what I send yesterday.

\begin{code}
function test2()
    qmc_data = EasyInit()
    b = getb(qmc_data)
    Nx = qmc_data.Nx
    phi0 = ones(Nx)
    phi1 = TSweep(phi0, qmc_data)
    r0 = phi1 - phi0
    mr0 = MMul(r0, qmc_data, b)
    # mr0=0. That's the problem I sent yesterday.
    println("M r0 = 0!! Here's the norm ", norm(mr0))
end
\end{code}

Yup! Same result.

\begin{code}
julia> test2()
M r0 = 0!! Here's the norm 0.00000e+00
\end{code}

\clearpage
So, let's check linearity one more time. Is
\[
\mm (\phi_0 + \vr_0) = \mm (\phi_0) + \mm(\vr_0) ?
\]
No.

\begin{code}
function Linear_QMC()
    qmc_data = EasyInit()
    b = getb(qmc_data)
    Nx = qmc_data.Nx
    phi0 = ones(Nx)
    phi1 = TSweep(phi0, qmc_data)
    r0 = phi1 - phi0
    #
    # Linearity?
    #
    v1 = phi0 + r0
    mv1 = MMul(v1, qmc_data, b)
    mphi0 = MMul(phi0, qmc_data, b)
    mr0 = MMul(r0, qmc_data, b) # this is zero!
    linerror = mv1 - (mphi0 + mr0) # supposed to be zero
    println("This ", norm(linerror), " is supposed to be zero.")
end
\end{code}

Here's the trouble. Even though {\tt test1} looked good. The map is
not linear.
\begin{code}

julia> Linear_QMC()
This 2.54114e-01 is supposed to be zero.
\end{code}

Help!

\end{document}
